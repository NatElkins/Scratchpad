// -----------------------------------------------------------------------------
//                                    ILGPU
//                     Copyright (c) 2016-2019 Marcel Koester
//                                www.ilgpu.net
//
// File: FSharpKernels.tt/FSharpKernels.cs
//
// This file is part of ILGPU and is distributed under the University of
// Illinois Open Source License. See LICENSE.txt for details.
// -----------------------------------------------------------------------------

<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<# var typeParameterRanges = Enumerable.Range(0, 14); #>
<# var delegateRange = from r in typeParameterRanges
    let range = Enumerable.Range(1, r + 1)
    select new
    {
        TypeParams = string.Join(", ", from rangeIdx in range select $"T{rangeIdx}"),
        FSharpTypeParams = string.Join(", ", from rangeIdx in range select $"FSharpFunc<T{rangeIdx}") + ", Unit" + string.Join("", from rangeIdx in range select $">"),
        FSharpCurryParamCount = r + 1,
        DefaultStreamLambdaParams = string.Join(", ", from rangeIdx in range select $"T{rangeIdx} param{rangeIdx}"),
        DefaultStreamArgs = string.Join(", ", from rangeIdx in range select $"param{rangeIdx}"),
        TypeRestrictions = string.Join(" ", from rangeIdx in range select $"where T{rangeIdx} : struct"),
    }; #>

using System;
using Microsoft.FSharp.Core;

namespace ILGPU.Runtime
{
    static class FSharpKernel
    {
        public static readonly Unit Unit = MakeUnit();

        private static Unit MakeUnit()
        {
            // Using reflection because ctor is internal
            return (Unit)Activator.CreateInstance(typeof(Unit), true);
        }
    }

<# foreach (var delegateParams in delegateRange) { #>
    sealed class FSharpKernel<TIndex, <#= delegateParams.TypeParams #>> : FSharpFunc<AcceleratorStream, FSharpFunc<TIndex, <#= delegateParams.FSharpTypeParams #>>>
        where TIndex : struct, IIndex
        <#= delegateParams.TypeRestrictions #>
    {
        private readonly Func<AcceleratorStream, TIndex, <#= delegateParams.TypeParams #>, Unit> _kernel;

        public FSharpKernel(Action<AcceleratorStream, TIndex, <#= delegateParams.TypeParams #>> kernel)
        {
            _kernel = new Func<AcceleratorStream, TIndex, <#= delegateParams.TypeParams #>, Unit>(
                (AcceleratorStream stream, TIndex index, <#= delegateParams.DefaultStreamLambdaParams #>) => {
                    kernel(stream, index, <#= delegateParams.DefaultStreamArgs #>);
                    return FSharpKernel.Unit;
                });;
        }

        public override FSharpFunc<TIndex, <#= delegateParams.FSharpTypeParams #>> Invoke(AcceleratorStream stream)
        {
            return new Converter<TIndex, <#= delegateParams.FSharpTypeParams #>>(index =>
<# for (var i = 1; i < delegateParams.FSharpCurryParamCount; i++) { #>
<# var range = Enumerable.Range(1 + i, delegateParams.FSharpCurryParamCount - i); #>
<# var converterResult = string.Join(", ", from rangeIdx in range select $"FSharpFunc<T{rangeIdx}") + ", Unit" + string.Join("", from rangeIdx in range select $">"); #>
                new Converter<T<#= i #>, <#= converterResult #>>(param<#= i #> =>
<# } #>
                new Converter<T<#= delegateParams.FSharpCurryParamCount #>, Unit>(param<#= delegateParams.FSharpCurryParamCount #> =>
                _kernel(stream, index, <#= delegateParams.DefaultStreamArgs #>)
                <#= new string(')', delegateParams.FSharpCurryParamCount + 1) #>;
        }
    }

<# } #>
}